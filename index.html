<!DOCTYPE html>
<html lang="vi">
<head>
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hỏa Chí Vô Song</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@700&family=Teko:wght@400;500;700&family=Bangers&display=swap" rel="stylesheet">
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; 
            background-color: #0a0a0a; font-family: 'Oswald', sans-serif; color: white;
        }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 20; pointer-events: none; }

        .game-layer { position: fixed; inset: 0; z-index: 100; display: none !important; pointer-events: none; }
        .active-layer { display: flex !important; pointer-events: auto; }

        #turn-counter-display {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            z-index: 200; pointer-events: none; display: none;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff9900;
            padding: 5px 25px;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(255, 153, 0, 0.3);
            font-family: 'Bangers', cursive;
            letter-spacing: 2px;
            text-align: center;
        }
        #turn-number { color: #ff9900; font-size: 28px; }
        .turn-label { font-size: 16px; color: #fff; text-transform: uppercase; margin-right: 10px; }

        /* Speed Control UI */
        #speed-control {
            position: fixed; top: 20px; right: 20px; z-index: 300; display: none;
            background: rgba(0,0,0,0.6); border: 1px solid #ff9900; border-radius: 8px; overflow: hidden;
        }
        .speed-btn {
            padding: 5px 15px; cursor: pointer; font-family: 'Teko'; font-size: 18px; color: white; transition: 0.2s;
        }
        .speed-btn.active { background: #ff9900; color: black; }

        #main-home { background: radial-gradient(circle at center, rgba(255, 255, 255, 0.1) 0%, rgba(0,0,0,0.4) 100%); flex-direction: column; justify-content: center; align-items: center; }
        .menu-content { text-align: center; animation: menuEntry 1.2s cubic-bezier(0.2, 0.8, 0.2, 1); }
        @keyframes menuEntry { 0% { opacity: 0; transform: scale(0.9); filter: blur(10px); } 100% { opacity: 1; transform: scale(1); filter: blur(0); } }
        
        .game-title { font-family: 'Bangers', cursive; font-size: clamp(3rem, 10vw, 6rem); line-height: 0.9; margin-bottom: 0; background: linear-gradient(to bottom, #fff 30%, #ff9900 60%, #ff4400 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px rgba(255, 153, 0, 0.4)); letter-spacing: -1px; font-style: italic; }
        .game-subtitle { font-family: 'Teko', sans-serif; font-size: 1.2rem; color: #ff9900; letter-spacing: 0.4em; text-transform: uppercase; margin-top: 0.5rem; margin-bottom: 4rem; text-shadow: 0 0 10px rgba(255, 153, 0, 0.5); }
        
        .btn-fancy { background: linear-gradient(135deg, #ff9900 0%, #ff5500 100%); color: black; font-family: 'Teko'; font-weight: bold; text-transform: uppercase; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0 100%); transition: 0.3s; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 15px rgba(255, 85, 0, 0.4); border: none; outline: none; }
        .btn-fancy:hover { transform: scale(1.05) skewX(-2deg); box-shadow: 0 0 30px rgba(255, 85, 0, 0.7); filter: brightness(1.2); }
        .btn-fancy:active { transform: scale(0.95); }

        #hero-gallery { background: rgba(0,0,0,0.9); backdrop-filter: blur(20px); flex-direction: column; padding: 20px; }
        .gallery-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; width: 100%; max-width: 800px; overflow-y: auto; padding: 20px; }
        .hero-info-card { background: linear-gradient(180deg, #222 0%, #000 100%); border: 2px solid #444; border-radius: 12px; padding: 15px; text-align: center; transition: 0.3s; cursor: pointer; position: relative; overflow: hidden; }
        .hero-info-card:hover { border-color: #ff9900; transform: translateY(-5px); }
        .lv-badge { position: absolute; top: 5px; right: 8px; font-size: 12px; color: #ff9900; font-family: 'Teko'; font-weight: bold; z-index: 10; }

        #hero-details { position: fixed; inset: 0; z-index: 500; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; padding: 20px; animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .details-container { background: #0c0c0c; border: 2px solid #333; border-radius: 20px; width: 100%; max-width: 500px; position: relative; box-shadow: 0 0 60px rgba(0, 0, 0, 0.8); overflow: hidden; display: flex; flex-direction: column; max-height: 90vh; }
        .details-header-bg { background: linear-gradient(180deg, #1a1a1a 0%, #0c0c0c 100%); padding: 15px 20px; text-align: center; border-bottom: 1px solid #222; position: relative; }
        .details-body { padding: 15px; flex: 1; overflow-y: auto; }
        
        .stat-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 15px; }
        .stat-row { background: #151515; border: 1px solid #222; border-radius: 6px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 4px 2px; }
        .stat-label { font-family: 'Teko'; color: #666; text-transform: uppercase; font-size: 11px; line-height: 1; margin-bottom: 2px; }
        .stat-value { font-family: 'Oswald'; color: #ff9900; font-size: 14px; line-height: 1; }

        .skill-section-title { font-family: 'Teko'; font-size: 16px; color: #ff9900; text-transform: uppercase; margin-bottom: 10px; border-left: 3px solid #ff9900; padding-left: 8px; letter-spacing: 1px; }
        .skill-item { display: flex; gap: 10px; background: #111; border: 1px solid #222; border-radius: 8px; padding: 8px; margin-bottom: 8px; transition: 0.2s; }
        .skill-item:hover { border-color: #444; background: #151515; }
        .skill-icon { width: 40px; height: 40px; border-radius: 6px; border: 1px solid #ff9900; flex-shrink: 0; overflow: hidden; background: #000; }
        .skill-info { flex: 1; }
        .skill-name { font-family: 'Teko'; font-size: 14px; color: #fff; text-transform: uppercase; margin-bottom: 1px; }
        .skill-desc { font-size: 10px; color: #777; line-height: 1.2; font-family: sans-serif; }

        #tactical-screen { background: radial-gradient(circle at center, rgba(30,30,50,0.9) 0%, rgba(10,10,15,0.98) 100%); backdrop-filter: blur(12px); flex-direction: column; }
        .formation-container { display: flex; flex-direction: column; gap: 12px; padding: 15px; background: rgba(0,242,255,0.06); border: 1px solid rgba(0,242,255,0.2); border-radius: 12px; }
        .row-label { font-family: 'Teko', sans-serif; font-size: 10px; color: #00f2ff; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; text-align: center; opacity: 0.9; }
        .formation-row { display: grid; grid-template-columns: repeat(3, 20px); gap: 8px; justify-content: center; }
        .slot { width: 20px; height: 20px; background: rgba(255,255,255,0.05); border: 1px dashed rgba(255,255,255,0.3); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; overflow: hidden; }
        .slot:hover { background: rgba(255,255,255,0.1); border-color: rgba(0,242,255,0.8); }
        .slot.occupied { border-style: solid; border-color: #00f2ff; background: rgba(0,242,255,0.2); box-shadow: 0 0 10px rgba(0,242,255,0.3); }

        .ui-unit-container { position: absolute; transform: translate(-50%, -100%); width: 70px; pointer-events: none; z-index: 1000; }
        .bar-bg { height: 4px; background: rgba(0,0,0,0.7); border-radius: 2px; overflow: hidden; border: 1px solid #444; margin-top: 1px; position: relative;}
        .hp-fill { height: 100%; background: #00ff88; transition: width 0.3s; }
        .mp-fill { height: 100%; background: #00ccff; transition: width 0.3s; }

        .damage-popup { position: absolute; font-family: 'Bangers', cursive; font-size: 24px; color: #fff; pointer-events: none; text-shadow: 2px 2px 0px #000, 0 0 10px rgba(255,255,255,0.5); z-index: 1000; white-space: nowrap; animation: damageFloat 0.8s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards; }
        @keyframes damageFloat { 0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; } 20% { transform: translate(-50%, -40px) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -100px) scale(1); opacity: 0; } }

        #skill-cinematic { position: fixed; inset: 0; z-index: 5000; pointer-events: none; display: none; align-items: center; justify-content: center; }
        .cinematic-bar { position: absolute; width: 200%; height: 120px; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), rgba(255,255,255,0.15), transparent); transform: rotate(-8deg) translateX(-120%); display: flex; align-items: center; justify-content: center; transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1); border-top: 2px solid rgba(255,255,255,0.4); border-bottom: 2px solid rgba(255,255,255,0.4); }
        .skill-name-text { font-family: 'Bangers', cursive; font-size: 50px; color: #fff; text-shadow: 0 0 25px rgba(255,255,255,0.9), 3px 3px 0px #000; letter-spacing: 6px; opacity: 0; transform: scale(1.5) skewX(-20deg); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .active-cinematic .cinematic-bar { transform: rotate(-8deg) translateX(0%); }
        .active-cinematic .skill-name-text { opacity: 1; transform: scale(1) skewX(-15deg); }

        #flash { position: fixed; inset: 0; background: white; opacity: 0; z-index: 2000; pointer-events: none; transition: opacity 0.2s; }
        .unit-card { min-width: 60px; height: 80px; background: linear-gradient(180deg, #252525 0%, #111 100%); border: 1px solid #444; border-radius: 6px; cursor: pointer; flex-shrink: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: all 0.2s ease; overflow: hidden; }
        .unit-card:hover { border-color: #888; background: #333; }
        .unit-card.selected { border-color: #ffaa00; background: rgba(255,170,0,0.15); box-shadow: 0 0 12px rgba(255,170,0,0.4); }

        #battle-ui { 
            background-image: url('https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/48db8cc8-bc54-4ac4-a791-ef75d6416986/ddo7jwl-e0115623-f5d6-4d8e-b2f5-c62edcb6877b.jpg/v1/fill/w_1024,h_577,q_75,strp/naruto_background_11_by_pungpp_ddo7jwl-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9NTc3IiwicGF0aCI6Ii9mLzQ4ZGI4Y2M4LWJjNTQtNGFjNC1hNzkxLWVmNzVkNjQxNjk4Ni9kZG83andsLWUwMTE1NjIzLWY1Z640D8E-B2F5-C62EDCB6877B.jpg/v1/fill/w_1024,h_577,q_75,strp/naruto_background_11_by_pungpp_ddo7jwl-fullview.jpg');
            background-size: cover;
            background-position: center;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="flash"></div>

<div id="turn-counter-display">
    <span class="turn-label">Lượt Đấu</span>
    <span id="turn-number">1</span>
</div>

<!-- Nút điều chỉnh tốc độ -->
<div id="speed-control" class="flex">
    <div id="btn-speed-1" class="speed-btn active" onclick="setGameSpeed(1)">x1</div>
    <div id="btn-speed-2" class="speed-btn" onclick="setGameSpeed(2)">x2</div>
</div>

<div id="skill-cinematic">
    <div class="cinematic-bar">
        <div id="skill-name" class="skill-name-text">AMATERASU!</div>
    </div>
</div>

<div id="main-home" class="game-layer active-layer flex">
    <div class="menu-content">
        <h1 class="game-title">HỎA CHÍ VÔ SONG</h1>
        <div class="game-subtitle">LEGEND BATTLE</div>
        <div class="flex flex-col gap-4 items-center">
            <div class="btn-fancy w-48 h-14 text-2xl shadow-xl" onclick="changeState('tactical')">BẮT ĐẦU</div>
            <div class="btn-fancy w-48 h-14 text-2xl shadow-xl opacity-80" onclick="changeState('gallery')">NHÂN VẬT</div>
        </div>
    </div>
</div>

<div id="hero-gallery" class="game-layer items-center justify-center">
    <div class="absolute top-4 right-4 text-orange-400 font-bold font-['Teko'] text-xl">BẠC: <span id="player-silver">5000</span></div>
    <h2 class="text-4xl font-bold text-orange-500 mb-8 tracking-widest font-['Teko'] uppercase">Nhẫn Giả Huyền Thoại</h2>
    <div id="gallery-container" class="gallery-grid"></div>
    <div class="mt-8 btn-fancy w-40 h-12 text-xl" onclick="changeState('home')">QUAY LẠI</div>
</div>

<div id="hero-details">
    <div class="details-container">
        <div class="details-header-bg">
            <div id="detail-icon" class="w-16 h-16 rounded-full mx-auto mb-2 border-4 border-orange-500 overflow-hidden flex items-center justify-center bg-black"></div>
            <h2 id="detail-name" class="text-3xl font-bold font-['Teko'] uppercase tracking-wider text-white">Tên</h2>
            <div class="flex justify-center items-center gap-2">
                <div id="detail-lv-text" class="text-orange-500 font-bold text-lg">CẤP 1</div>
                <p id="detail-info" class="text-white/40 text-[9px] font-bold tracking-[0.1em] uppercase"></p>
            </div>
        </div>

        <div class="details-body">
            <div class="stat-grid">
                <div class="stat-row"><span class="stat-label">HP</span><span id="stat-hp" class="stat-value">0</span></div>
                <div class="stat-row"><span class="stat-label">CÔNG</span><span id="stat-atk" class="stat-value">0</span></div>
                <div class="stat-row"><span class="stat-label">THỦ</span><span id="stat-def" class="stat-value">0</span></div>
                <div class="stat-row"><span class="stat-label">TỐC</span><span id="stat-spd" class="stat-value">0</span></div>
            </div>

            <div class="skill-section-title">Nhẫn Thuật Kỹ Năng</div>
            <div id="skill-list" class="space-y-2"></div>
        </div>

        <div class="p-4 border-t border-white/5 bg-black flex gap-3 justify-center">
            <div class="btn-fancy flex-1 h-10 flex flex-col" onclick="upgradeHero()">
                <span class="text-md leading-none">NÂNG CẤP</span>
                <span id="upgrade-cost" class="text-[9px] opacity-80">0 BẠC</span>
            </div>
            <div class="btn-fancy flex-1 h-10 text-md" onclick="closeDetails()">ĐÓNG</div>
        </div>
    </div>
</div>

<div id="tactical-screen" class="game-layer py-4 px-4 flex flex-col items-center">
    <div class="absolute top-4 left-4"><div class="btn-fancy w-24 h-8 text-[12px]" onclick="changeState('home')">QUAY LẠI</div></div>
    <div class="w-full max-w-xs flex-1 flex flex-col items-center">
        <div class="text-center mb-6"><h3 class="text-lg font-bold text-white tracking-widest uppercase mb-1">Đội Hình</h3></div>
        <div class="flex-1 flex items-center justify-center">
            <div class="formation-container">
                <div>
                    <div class="row-label">Hàng Trước</div>
                    <div class="formation-row">
                        <div class="slot" data-pos="3"></div>
                        <div class="slot" data-pos="4"></div>
                        <div class="slot" data-pos="5"></div>
                    </div>
                </div>
                <div>
                    <div class="row-label">Hàng Sau</div>
                    <div class="formation-row">
                        <div class="slot" data-pos="0"></div>
                        <div class="slot" data-pos="1"></div>
                        <div class="slot" data-pos="2"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="mt-6 mb-4 w-full flex justify-center"><div class="btn-fancy w-40 h-10 text-md tracking-widest" onclick="triggerBattleStart()">XUẤT QUÂN</div></div>
    </div>
    <div class="w-full mt-auto"><div id="unit-pool-container" class="w-full bg-white/5 backdrop-blur-sm p-2 border-t border-white/20 overflow-x-auto flex gap-2"></div></div>
</div>

<div id="battle-ui" class="game-layer">
    <div id="battle-layer" class="relative w-full h-full"></div>
    <div class="absolute top-5 left-5 btn-fancy w-20 h-7 text-[10px]" onclick="stopBattleAndReturn()" style="pointer-events: auto;">RÚT LUI</div>
</div>

<script>
    let scene, camera, renderer, clock;
    let units = [];
    let particles = [];
    let skillMeshes = [];
    let gameState = 'home';
    let isCombatActive = false;
    let battleTurnCount = 1;
    let originalCameraPos = new THREE.Vector3(0, 350, 900);
    let playerSilver = 5000;
    let selectedHeroInDetails = null;
    let selectedHeroId = null;
    let currentFormation = [{ slot: 4, unitId: 'it1' }];
    
    // Biến điều tốc game (Mặc định x1)
    let gameSpeedMultiplier = 1;

    const sounds = {
        bgm: new Audio('https://codesandbox.io/api/v1/sandboxes/8f8v9v/files/assets/naruto_theme.mp3'),
        chidori: new Audio('chidori_sound.mp3') 
    };

    sounds.bgm.loop = true;
    sounds.bgm.volume = 0.3;
    sounds.chidori.volume = 0.9;

    let isAudioInitialized = false;

    function initializeAudio() {
        if (!isAudioInitialized) {
            sounds.bgm.play().catch(e => console.log("BGM Play Error:", e));
            sounds.chidori.load();
            isAudioInitialized = true;
        }
    }

    function playSound(name) {
        if(sounds[name]) {
            sounds[name].pause();
            sounds[name].currentTime = 0;
            sounds[name].play().catch(e => console.log(`Sound Play Error (${name}):`, e));
        }
    }

    function setGameSpeed(speed) {
        gameSpeedMultiplier = speed;
        document.getElementById('btn-speed-1').classList.toggle('active', speed === 1);
        document.getElementById('btn-speed-2').classList.toggle('active', speed === 2);
    }

    const allHeroData = [
        { 
            id: 'n1', name: 'Naruto', skill: 'RASENGAN', color: 0xffaa00, hp: 1500, atk: 250, def: 180, spd: 120, lv: 1, skillColor: 0x44ccff, info: 'Cửu vĩ nhẫn giả', 
            avatar: 'https://bloganchoi.com/wp-content/uploads/2017/03/naruto-uzumaki.jpg',
            skills: [
                { name: 'Phân thân chi thuật', desc: 'Tạo ra nhiều phân thân gây nhiễu loạn đối thủ.', icon: 'https://i.pinimg.com/236x/8f/58/05/8f5805566f1082be987c93663a825f61.jpg' },
                { name: 'Rasengan', desc: 'Sử dụng vòng xoáy chakra cực đại tấn công đơn mục tiêu.', icon: 'https://i.pinimg.com/736x/2c/31/34/2c3134372990666d69f91f7a0487574b.jpg' },
                { name: 'Oodama Rasengan', desc: 'Rasengan khổng lồ gây sát thương lan rộng.', icon: 'https://i.pinimg.com/236x/32/3d/8c/323d8c85c2759f635661601004245657.jpg' },
                { name: 'Cửu Vĩ Chế Độ', desc: 'Giải phóng sức mạnh Kurama, tăng mạnh tấn công và tốc độ.', icon: 'https://i.pinimg.com/236x/43/61/6f/43616f731c5188f56645353163353531.jpg' }
            ]
        },
        { 
            id: 's1', name: 'Sasuke', skill: 'CHIDORI', color: 0x4444ff, hp: 1300, atk: 280, def: 150, spd: 140, lv: 1, skillColor: 0x44ccff, info: 'Tộc nhân Uchiha', 
            avatar: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTwZ5xhMLgnbM0Ll_I7E322P3hqRHP1AFRwdA&s',
            skills: [
                { name: 'Hỏa Độn: Hào Hỏa Cầu', desc: 'Phun ra ngọn lửa khổng lồ thiêu rụi kẻ địch trước mặt.', icon: 'https://i.pinimg.com/236x/5c/15/45/5c154562575440626305606456204060.jpg' },
                { name: 'Chidori', desc: 'Tập trung sấm sét vào tay và lao thẳng vào mục tiêu.', icon: 'https://i.pinimg.com/236x/6c/4d/5e/6c4d5e1a1a6b0a1a1a6b0a1a1a6b0a1a.jpg' },
                { name: 'Sharingan', desc: 'Nhãn thuật sao chép và thấu thị, tăng khả năng né tránh.', icon: 'https://i.pinimg.com/236x/1a/1a/1a/1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a.jpg' },
                { name: 'Susanoo', desc: 'Triệu hồi thực thể bảo hộ khổng lồ, công thủ toàn diện.', icon: 'https://i.pinimg.com/236x/7d/5c/7d/7d5c7d5c7d5c7d5c7d5c7d5c7d5c7d5c.jpg' }
            ]
        },
        { 
            id: 'k1', name: 'Kakashi', skill: 'LÔI THIẾT', color: 0x88ff88, hp: 1400, atk: 230, def: 200, spd: 130, lv: 1, skillColor: 0x00ffff, info: 'Ninja sao chép', 
            avatar: 'https://wibu.com.vn/wp-content/uploads/2024/04/Hatake-Kakashi.jpg',
            skills: [
                { name: 'Thổ Độn: Thổ Lưu Bích', desc: 'Dựng tường đá ngăn chặn mọi đòn tấn công vật lý.', icon: 'https://i.pinimg.com/236x/2b/2b/2b/2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b.jpg' },
                { name: 'Lôi Thiết', desc: 'Cấp độ cao hơn của Chidori, sát thương xuyên thấu cực cao.', icon: 'https://i.pinimg.com/236x/3c/3c/3c/3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c.jpg' },
                { name: 'Triệu Hồi Chi Thuật', desc: 'Triệu hồi đàn chó săn nhẫn giả để truy vết và cầm chân.', icon: 'https://i.pinimg.com/236x/4d/4d/4d/4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d.jpg' },
                { name: 'Kamui', desc: 'Sử dụng Mangekyo Sharingan dịch chuyển bộ phận mục tiêu.', icon: 'https://i.pinimg.com/236x/5e/5e/5e/5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e5e.jpg' }
            ]
        },
        { 
            id: 'it1', name: 'Itachi', skill: 'AMATERASU', color: 0xff4444, hp: 1600, atk: 300, def: 160, spd: 110, lv: 1, skillColor: 0x000000, info: 'Bậc thầy ảo thuật', 
            avatar: 'https://anhdep.edu.vn/upload/2024/08/bo-suu-tap-anh-itachi-uchiha-dep-nhat-chat-luong-cao-4k-31.webp',
            skills: [
                { name: 'Hỏa Độn: Hào Hỏa Cầu', desc: 'Tạo ra quả cầu lửa khổng lồ thiêu cháy mọi thứ.', icon: 'https://i.pinimg.com/236x/5c/15/45/5c154562575440626305606456204060.jpg' },
                { name: 'Amaterasu', desc: 'Ngọn lửa đen vĩnh cửu không thể bị dập tắt.', icon: 'https://i.pinimg.com/236x/b2/b2/b2/b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2.jpg' },
                { name: 'Tsukuyomi', desc: 'Giam cầm tinh thần kẻ địch trong 72 giờ tra tấn ảo ảnh.', icon: 'https://i.pinimg.com/236x/c3/c3/c3/c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3c3.jpg' },
                { name: 'Izanami', desc: 'Cấm thuật nhẫn thuật đưa kẻ địch vào vòng lặp thời gian vô tận.', icon: 'https://i.pinimg.com/236x/d4/d4/d4/d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4d4.jpg' }
            ]
        }
    ];

    function init() {
        scene = new THREE.Scene();
        scene.background = null; 
        
        camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 1, 5000);
        camera.position.copy(originalCameraPos);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, logarithmicDepthBuffer: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();
        
        const ambient = new THREE.AmbientLight(0xffffff, 2.5); 
        scene.add(ambient);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
        mainLight.position.set(500, 1000, 500);
        scene.add(mainLight);

        const fillLight = new THREE.PointLight(0xffffff, 1.5);
        fillLight.position.set(-500, 500, 500);
        scene.add(fillLight);
        
        renderTacticalUI();
        renderGallery();
        animate();
    }

    function changeState(state) {
        gameState = state;
        document.querySelectorAll('.game-layer').forEach(l => l.classList.remove('active-layer'));
        
        const turnDisplay = document.getElementById('turn-counter-display');
        const speedUI = document.getElementById('speed-control');

        if(state === 'battle') {
            turnDisplay.style.display = 'block';
            speedUI.style.display = 'flex';
            battleTurnCount = 1;
            document.getElementById('turn-number').innerText = battleTurnCount;
        } else {
            turnDisplay.style.display = 'none';
            speedUI.style.display = 'none';
        }

        let targetId = 'main-home';
        if(state === 'tactical') { targetId = 'tactical-screen'; renderTacticalUI(); }
        else if(state === 'battle') targetId = 'battle-ui';
        else if(state === 'gallery') { targetId = 'hero-gallery'; document.getElementById('player-silver').innerText = playerSilver; renderGallery(); }
        
        const el = document.getElementById(targetId);
        if(el) el.classList.add('active-layer');
    }

    function renderGallery() {
        const container = document.getElementById('gallery-container');
        if (!container) return;
        container.innerHTML = '';
        allHeroData.forEach(hero => {
            const card = document.createElement('div');
            card.className = 'hero-info-card';
            const avatarHtml = hero.avatar 
                ? `<img src="${hero.avatar}" class="w-full h-full object-cover">`
                : `<div class="w-full h-full" style="background: #${hero.color.toString(16).padStart(6,'0')}"></div>`;
            card.innerHTML = `
                <div class="lv-badge">CẤP.${hero.lv}</div>
                <div class="w-12 h-12 rounded-full mx-auto mb-3 shadow-lg overflow-hidden border-2 border-white">
                    ${avatarHtml}
                </div>
                <div class="text-xl font-bold text-white font-['Teko'] uppercase">${hero.name}</div>
                <div class="text-xs text-orange-400 font-bold mb-2">${hero.skill}</div>
                <div class="text-[10px] text-gray-400 italic">${hero.info}</div>
            `;
            card.onclick = () => showHeroDetails(hero);
            container.appendChild(card);
        });
    }

    function showHeroDetails(hero) {
        selectedHeroInDetails = hero;
        const multiplier = 1 + (hero.lv - 1) * 0.15;
        document.getElementById('detail-name').innerText = hero.name;
        document.getElementById('detail-lv-text').innerText = `CẤP ${hero.lv}`;
        document.getElementById('detail-info').innerText = hero.info;
        const detailIcon = document.getElementById('detail-icon');
        detailIcon.innerHTML = hero.avatar ? `<img src="${hero.avatar}" class="w-full h-full object-cover">` : '';
        detailIcon.style.backgroundColor = hero.avatar ? 'transparent' : `#${hero.color.toString(16).padStart(6,'0')}`;
        document.getElementById('stat-hp').innerText = Math.floor(hero.hp * multiplier);
        document.getElementById('stat-atk').innerText = Math.floor(hero.atk * multiplier);
        document.getElementById('stat-def').innerText = Math.floor(hero.def * multiplier);
        document.getElementById('stat-spd').innerText = Math.floor(hero.spd * multiplier);
        const skillList = document.getElementById('skill-list');
        skillList.innerHTML = '';
        if (hero.skills) {
            hero.skills.forEach(skill => {
                const item = document.createElement('div');
                item.className = 'skill-item';
                item.innerHTML = `<div class="skill-icon"><img src="${skill.icon}" class="w-full h-full object-cover"></div><div class="skill-info"><div class="skill-name">${skill.name}</div><div class="skill-desc">${skill.desc}</div></div>`;
                skillList.appendChild(item);
            });
        }
        document.getElementById('upgrade-cost').innerText = `${hero.lv * 1000} BẠC`;
        document.getElementById('hero-details').style.display = 'flex';
    }

    function upgradeHero() {
        if(!selectedHeroInDetails) return;
        const cost = selectedHeroInDetails.lv * 1000;
        if(playerSilver >= cost) {
            playerSilver -= cost;
            selectedHeroInDetails.lv++;
            document.getElementById('player-silver').innerText = playerSilver;
            showHeroDetails(selectedHeroInDetails);
            renderGallery();
        }
    }

    function closeDetails() { 
        document.getElementById('hero-details').style.display = 'none'; 
    }

    function renderTacticalUI() {
        const pool = document.getElementById('unit-pool-container');
        pool.innerHTML = '';
        allHeroData.forEach(u => {
            const inForm = currentFormation.some(f => f.unitId === u.id);
            const card = document.createElement('div');
            card.className = `unit-card ${selectedHeroId === u.id ? 'selected' : ''} ${inForm ? 'opacity-30' : ''}`;
            const avtPreview = u.avatar ? `<img src="${u.avatar}" class="w-full h-full object-cover">` : '';
            card.innerHTML = `<div class="w-6 h-6 rounded-full mb-1 flex items-center justify-center overflow-hidden border border-white/20">${avtPreview}</div><div class="text-[8px] font-bold text-gray-200 uppercase">${u.name} CẤP.${u.lv}</div>`;
            card.onclick = () => { if(!inForm) { selectedHeroId = (selectedHeroId === u.id) ? null : u.id; } renderTacticalUI(); };
            pool.appendChild(card);
        });

        document.querySelectorAll('.slot').forEach(slot => {
            const pos = parseInt(slot.dataset.pos);
            const item = currentFormation.find(f => f.slot === pos);
            slot.innerHTML = '';
            slot.classList.toggle('occupied', !!item);
            if(item) {
                const u = allHeroData.find(h => h.id === item.unitId);
                const content = u.avatar ? `<img src="${u.avatar}" class="w-full h-full object-cover">` : '';
                slot.innerHTML = `<div class="relative w-full h-full flex items-center justify-center">${content}</div>`;
            }
            slot.onclick = () => {
                if(item) currentFormation = currentFormation.filter(f => f.slot !== pos);
                else if(selectedHeroId) {
                    currentFormation = currentFormation.filter(f => f.unitId !== selectedHeroId);
                    currentFormation.push({ slot: pos, unitId: selectedHeroId });
                    selectedHeroId = null;
                }
                renderTacticalUI();
            };
        });
    }

    function triggerBattleStart() {
        if(currentFormation.length === 0) return;
        
        initializeAudio();

        changeState('battle');
        const flash = document.getElementById('flash');
        flash.style.opacity = '1';
        setTimeout(() => {
            units.forEach(u => { if(u.bar) u.bar.remove(); scene.remove(u.group); });
            units = [];
            document.getElementById('battle-layer').innerHTML = '';
            spawnBattleUnits();
            isCombatActive = true;
            startCombatLoop();
            flash.style.opacity = '0';
        }, 200);
    }

    function stopBattleAndReturn() {
        isCombatActive = false;
        camera.position.copy(originalCameraPos);
        units.forEach(u => { scene.remove(u.group); if(u.bar) u.bar.remove(); u.dots.forEach(d => { if(d.mesh) scene.remove(d.mesh); }); });
        units = [];
        skillMeshes.forEach(m => scene.remove(m));
        skillMeshes = [];
        changeState('tactical');
    }

    function spawnBattleUnits() {
        currentFormation.forEach((f, idx) => {
            const data = allHeroData.find(u => u.id === f.unitId);
            const g = createChar(data.name);
            const col = f.slot % 3;
            const isFront = f.slot >= 3;
            g.position.set(isFront ? -300 : -420, -85, (col - 1) * 120);
            g.rotation.y = Math.PI/2;
            scene.add(g);
            const multiplier = 1 + (data.lv - 1) * 0.15;
            const finalHp = Math.floor(data.hp * multiplier);
            const finalAtk = Math.floor(data.atk * multiplier);
            units.push({ ...data, id: 'ally_'+idx, group: g, cur: finalHp, maxHp: finalHp, mp: 0, atk: finalAtk, enemy: false, dots: [] });
        });
        const bossG = createChar('Madara');
        bossG.position.set(400, -85, 0); bossG.scale.set(4, 4, 4); bossG.rotation.y = -Math.PI/2;
        scene.add(bossG);
        units.push({ id: 'boss_m', name: 'Madara', skill: 'KAISETSU', skillColor: 0xff4400, group: bossG, cur: 45000, maxHp: 45000, mp: 0, enemy: true, isBoss: true, dots: [] });
    }

    function createChar(name) {
        const g = new THREE.Group();
        const skinColor = 0xffdbac;
        let suitColor = 0x333333, hairColor = 0x000000, hairShape = 'spiky';
        if(name === 'Naruto') { suitColor = 0xff6600; hairColor = 0xffdd00; }
        else if(name === 'Sasuke') { suitColor = 0x1a1a2e; hairColor = 0x000000; }
        else if(name === 'Kakashi') { suitColor = 0x4a5d4e; hairColor = 0xcccccc; hairShape = 'sideways'; }
        else if(name === 'Itachi') { suitColor = 0x111111; hairColor = 0x000000; }
        else if(name === 'Madara') { suitColor = 0x4a0000; hairColor = 0x000000; hairShape = 'long'; }
        
        const mat = (c) => new THREE.MeshStandardMaterial({color: c, roughness: 0.6, metalness: 0.1});
        
        const body = new THREE.Mesh(new THREE.BoxGeometry(20, 32, 12), mat(suitColor));
        body.position.y = 16; g.add(body);
        const head = new THREE.Mesh(new THREE.BoxGeometry(18, 18, 18), mat(skinColor));
        head.position.y = 41; g.add(head);
        const rightShoulder = new THREE.Group();
        rightShoulder.position.set(12, 28, 0); g.add(rightShoulder);
        g.userData.rightShoulder = rightShoulder;
        const rightArm = new THREE.Mesh(new THREE.BoxGeometry(6, 20, 6), mat(suitColor));
        rightArm.position.y = -8; rightShoulder.add(rightArm);
        const leftArm = new THREE.Mesh(new THREE.BoxGeometry(6, 20, 6), mat(suitColor));
        leftArm.position.set(-13, 20, 0); g.add(leftArm);
        const legG = new THREE.BoxGeometry(8, 20, 8);
        const lLeg = new THREE.Mesh(legG, mat(suitColor)); lLeg.position.set(-5, -5, 0); g.add(lLeg);
        const rLeg = new THREE.Mesh(legG, mat(suitColor)); rLeg.position.set(5, -5, 0); g.add(rLeg);
        const hairG = new THREE.Group(); hairG.position.y = 48;
        if(hairShape === 'spiky') { for(let i=0; i<6; i++) { const spike = new THREE.Mesh(new THREE.ConeGeometry(4, 12, 4), mat(hairColor)); spike.position.set((Math.random()-0.5)*15, 5, (Math.random()-0.5)*15); spike.rotation.x = (Math.random()-0.5); hairG.add(spike); } }
        else if(hairShape === 'long') { const longHair = new THREE.Mesh(new THREE.BoxGeometry(20, 30, 8), mat(hairColor)); longHair.position.set(0, -10, -8); hairG.add(longHair); }
        else if(hairShape === 'sideways') { const side = new THREE.Mesh(new THREE.ConeGeometry(10, 20, 4), mat(hairColor)); side.rotation.z = Math.PI/3; side.position.set(-5, 5, 0); hairG.add(side); }
        g.add(hairG);
        return g;
    }

    function showDamage(target, amount, color = "#fff") {
        if(!target || !target.group) return;
        const v = new THREE.Vector3(); target.group.getWorldPosition(v);
        const p = v.clone().add(new THREE.Vector3(0, target.isBoss ? 150 : 80, 0)).project(camera);
        const el = document.createElement('div');
        el.className = 'damage-popup'; el.innerText = amount; el.style.color = color;
        el.style.left = `${(p.x * 0.5 + 0.5) * window.innerWidth}px`;
        el.style.top = `${(p.y * -0.5 + 0.5) * window.innerHeight}px`;
        document.getElementById('battle-layer').appendChild(el);
        setTimeout(() => el.remove(), 800 / gameSpeedMultiplier);
    }

    async function startCombatLoop() {
        while(isCombatActive) {
            document.getElementById('turn-number').innerText = battleTurnCount;
            let turnQueue = [...units].filter(u => u.cur > 0);
            for(let u of turnQueue) {
                if(!isCombatActive || u.cur <= 0) continue;
                if(u.dots && u.dots.length > 0) {
                    u.dots.forEach(dot => {
                        const dmg = dot.damage; u.cur = Math.max(0, u.cur - dmg);
                        showDamage(u, dmg, "#000"); createVFX(u.group.position, dot.color, 5, 'burn');
                    });
                }
                if(u.cur <= 0) continue;
                let target = null;
                if(u.enemy) {
                    let allies = units.filter(t => !t.enemy && t.cur > 0);
                    if(allies.length > 0) {
                        allies.sort((a, b) => b.group.position.x - a.group.position.x);
                        let maxX = allies[0].group.position.x;
                        let frontLine = allies.filter(a => Math.abs(a.group.position.x - maxX) < 10);
                        target = frontLine[Math.floor(Math.random() * frontLine.length)];
                    }
                } else { target = units.find(t => t.enemy && t.cur > 0); }
                if(!target) break;

                if (battleTurnCount === 1 && !u.enemy) {
                    await performSpecialAttack(u, target);
                    u.mp = 100;
                } else if (u.mp >= 100) {
                    await performUltimate(u, target);
                    u.mp = 0;
                } else {
                    await performAttack(u, target);
                    u.mp = Math.min(100, u.mp + 50);
                }

                await new Promise(r => setTimeout(r, 800 / gameSpeedMultiplier));
                if(units.filter(u => !u.enemy && u.cur > 0).length === 0 || units.filter(u => u.enemy && u.cur > 0).length === 0) { isCombatActive = false; break; }
            }
            if(isCombatActive) { battleTurnCount++; await new Promise(r => setTimeout(r, 600 / gameSpeedMultiplier)); }
        }
    }

    async function performAttack(u, target) {
        const start = u.group.position.clone();
        const hit = target.group.position.clone().add(new THREE.Vector3(u.enemy?80:-80, 0, 0));
        await tween(u.group.position, hit, 200 / gameSpeedMultiplier, "easeIn");
        const dmg = (u.enemy ? 350 : (u.atk || 400));
        target.cur = Math.max(0, target.cur - dmg);
        showDamage(target, dmg); createVFX(target.group.position, 0xffffff, 8, 'spark'); screenShake(5, 100);
        await tween(u.group.position, start, 250 / gameSpeedMultiplier, "easeOut");
    }

    async function performSpecialAttack(u, target) {
        if (u.name === 'Naruto') {
            await performNarutoSpecial(u, target);
        } else if (u.name === 'Itachi' || u.name === 'Sasuke') {
            await performFireballSpecial(u, target);
        } else if (u.name === 'Kakashi') {
            await performKakashiSpecial(u, target);
        } else {
            let skillMesh;
            if(u.skill === 'CHIDORI' || u.skill === 'LÔI THIẾT') {
                skillMesh = createChidoriMesh();
                playSound('chidori'); 
            } else {
                skillMesh = new THREE.Mesh(new THREE.SphereGeometry(15), new THREE.MeshBasicMaterial({color: u.skillColor}));
            }
            
            if(u.group.userData.rightShoulder) { tweenRotation(u.group.userData.rightShoulder, { z: -Math.PI / 2, x: 0 }, 250 / gameSpeedMultiplier, "easeIn"); }
            skillMesh.position.copy(u.group.position).add(new THREE.Vector3(30, 30, 0));
            scene.add(skillMesh); skillMeshes.push(skillMesh);
            
            const startPos = u.group.position.clone();
            const targetPos = target.group.position.clone().add(new THREE.Vector3(u.enemy ? 100 : -100, 0, 0));
            await tween(u.group.position, targetPos, 400 / gameSpeedMultiplier, "easeIn");
            const dmg = Math.floor((u.atk || 400) * 2.5);
            target.cur = Math.max(0, target.cur - dmg);
            showDamage(target, dmg, "#ffaa00");
            createVFX(target.group.position, u.skillColor, 20, 'spark');
            screenShake(8, 200);
            scene.remove(skillMesh);
            skillMeshes = skillMeshes.filter(m => m !== skillMesh);
            if(u.group.userData.rightShoulder) tweenRotation(u.group.userData.rightShoulder, { z: 0, x: 0 }, 250 / gameSpeedMultiplier, "easeOut");
            await tween(u.group.position, startPos, 400 / gameSpeedMultiplier, "easeOut");
        }
    }

    async function performKakashiSpecial(u, target) {
        const startPos = u.group.position.clone();
        
        // Tạo Lôi Thiết bám vào Kakashi
        const chidori = createChidoriMesh();
        chidori.scale.set(0.7, 0.7, 0.7);
        scene.add(chidori); skillMeshes.push(chidori);
        playSound('chidori');

        // Hàm cập nhật vị trí Lôi Thiết bám theo Kakashi
        const updateSkillPos = () => {
            if (chidori && u.group) {
                chidori.position.copy(u.group.position).add(new THREE.Vector3(20, 25, 0));
                // Tạo thêm tia lửa nhỏ dọc đường di chuyển
                if (Math.random() > 0.3) createVFX(u.group.position, 0x00f2ff, 2, 'spark');
            }
        };

        // Bắt đầu cập nhật liên tục
        const skillInterval = setInterval(updateSkillPos, 16);

        // 1. Di chuyển nhanh đến trước mặt địch
        const frontOfEnemy = target.group.position.clone().add(new THREE.Vector3(-100, 0, 0));
        await tween(u.group.position, frontOfEnemy, 250 / gameSpeedMultiplier, "easeOut");
        
        // 2. Nhảy lên cao
        const highPos = frontOfEnemy.clone().add(new THREE.Vector3(0, 350, 0));
        await tween(u.group.position, highPos, 300 / gameSpeedMultiplier, "easeOut");
        
        // 3. Rơi xuống theo hình dích dắc (sấm sét)
        const targetPos = target.group.position.clone().add(new THREE.Vector3(-40, 0, 0));
        const mid1 = highPos.clone().lerp(targetPos, 0.33).add(new THREE.Vector3(120, 0, 0));
        const mid2 = highPos.clone().lerp(targetPos, 0.66).add(new THREE.Vector3(-120, 0, 0));
        
        const lightningSpeed = 70 / gameSpeedMultiplier;
        await tween(u.group.position, mid1, lightningSpeed, "linear");
        createVFX(u.group.position, 0x00f2ff, 15, 'spark');

        await tween(u.group.position, mid2, lightningSpeed, "linear");
        createVFX(u.group.position, 0x00f2ff, 15, 'spark');

        // Lao thẳng xuống cắm đất
        await tween(u.group.position, targetPos, lightningSpeed, "easeIn");
        
        // Ngừng cập nhật vị trí vì đã tới đích
        clearInterval(skillInterval);
        chidori.position.copy(targetPos).add(new THREE.Vector3(0, 25, 0));

        // 4. Chạm đất, gây nổ sét
        const dmg = Math.floor((u.atk || 400) * 2.8);
        target.cur = Math.max(0, target.cur - dmg);
        showDamage(target, dmg, "#00ffff");
        createVFX(target.group.position, 0x00f2ff, 50, 'chidori');
        screenShake(12, 400);

        // Dọn dẹp skill và quay về vị trí ban đầu
        scene.remove(chidori);
        skillMeshes = skillMeshes.filter(m => m !== chidori);
        await new Promise(r => setTimeout(r, 400 / gameSpeedMultiplier));
        await tween(u.group.position, startPos, 500 / gameSpeedMultiplier, "easeOut");
    }

    async function performNarutoSpecial(u, target) {
        const startPos = u.group.position.clone();
        const clones = [];
        createVFX(u.group.position, 0xffffff, 30, 'smoke');
        for(let i=0; i<2; i++) {
            const clone = createChar('Naruto');
            clone.position.copy(u.group.position).add(new THREE.Vector3(0, 0, (i === 0 ? 60 : -60)));
            clone.rotation.y = Math.PI/2;
            clone.scale.set(0.1, 0.1, 0.1); 
            scene.add(clone);
            clones.push(clone);
            tweenScale(clone, new THREE.Vector3(1, 1, 1), 250 / gameSpeedMultiplier);
        }
        await new Promise(r => setTimeout(r, 250 / gameSpeedMultiplier));
        const targetPosCenter = target.group.position.clone().add(new THREE.Vector3(-80, 0, 0));
        const targetPosUp = target.group.position.clone().add(new THREE.Vector3(-80, 0, 60));
        const targetPosDown = target.group.position.clone().add(new THREE.Vector3(-80, 0, -60));
        const p1 = tween(u.group.position, targetPosCenter, 400 / gameSpeedMultiplier, "easeIn");
        const p2 = tween(clones[0].position, targetPosUp, 400 / gameSpeedMultiplier, "easeIn");
        const p3 = tween(clones[1].position, targetPosDown, 400 / gameSpeedMultiplier, "easeIn");
        await Promise.all([p1, p2, p3]);
        const dmg = Math.floor((u.atk || 400) * 2.5);
        target.cur = Math.max(0, target.cur - dmg);
        showDamage(target, dmg, "#ffaa00");
        createVFX(target.group.position, 0xffaa00, 30, 'spark');
        screenShake(10, 300);
        await new Promise(r => setTimeout(r, 400 / gameSpeedMultiplier));
        const b1 = tween(u.group.position, startPos, 400 / gameSpeedMultiplier, "easeOut");
        const b2 = tween(clones[0].position, startPos.clone().add(new THREE.Vector3(0, 0, 60)), 400 / gameSpeedMultiplier, "easeOut");
        const b3 = tween(clones[1].position, startPos.clone().add(new THREE.Vector3(0, 0, -60)), 400 / gameSpeedMultiplier, "easeOut");
        await Promise.all([b1, b2, b3]);
        clones.forEach(clone => {
            createVFX(clone.position, 0xffffff, 20, 'smoke');
            scene.remove(clone);
        });
    }

    async function performFireballSpecial(u, target) {
        if(u.group.userData.rightShoulder) tweenRotation(u.group.userData.rightShoulder, { z: -Math.PI/4, x: 0.5 }, 300 / gameSpeedMultiplier, "easeIn");
        await new Promise(r => setTimeout(r, 400 / gameSpeedMultiplier));

        const fireball = new THREE.Group();
        const core = new THREE.Mesh(new THREE.SphereGeometry(30, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff4400 }));
        const glow = new THREE.Mesh(new THREE.SphereGeometry(45, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.4 }));
        fireball.add(core); fireball.add(glow);
        
        fireball.position.copy(u.group.position).add(new THREE.Vector3(40, 40, 0));
        fireball.scale.set(0.1, 0.1, 0.1);
        scene.add(fireball); skillMeshes.push(fireball);

        await tweenScale(fireball, new THREE.Vector3(1, 1, 1), 500 / gameSpeedMultiplier, "easeOut");

        const targetPos = target.group.position.clone();
        await tween(fireball.position, targetPos, 600 / gameSpeedMultiplier, "easeIn");

        const dmg = Math.floor((u.atk || 400) * 2.5);
        target.cur = Math.max(0, target.cur - dmg);
        showDamage(target, dmg, "#ff5500");
        createVFX(target.group.position, 0xff4400, 50, 'fire');
        screenShake(12, 400);

        scene.remove(fireball);
        skillMeshes = skillMeshes.filter(m => m !== fireball);
        if(u.group.userData.rightShoulder) tweenRotation(u.group.userData.rightShoulder, { z: 0, x: 0 }, 300 / gameSpeedMultiplier, "easeOut");
    }

    async function performUltimate(u, target) {
        const cinematic = document.getElementById('skill-cinematic');
        const skillNameEl = document.getElementById('skill-name');
        skillNameEl.innerText = u.skill;
        cinematic.style.display = 'flex';
        setTimeout(() => cinematic.classList.add('active-cinematic'), 50);
        let skillMesh;
        if(u.skill === 'RASENGAN') {
            skillMesh = createAnimeRasengan();
        } else if(u.skill === 'CHIDORI' || u.skill === 'LÔI THIẾT') {
            skillMesh = createChidoriMesh();
            playSound('chidori'); 
        } else if(u.skill === 'AMATERASU') {
            skillMesh = createAmaterasuVFX(target.group.position);
        } else {
            skillMesh = new THREE.Mesh(new THREE.SphereGeometry(30), new THREE.MeshBasicMaterial({color: u.skillColor}));
        }
        if(u.skill !== 'AMATERASU' && u.group.userData.rightShoulder) { tweenRotation(u.group.userData.rightShoulder, { z: -Math.PI / 1.8, x: 0.2 }, 400 / gameSpeedMultiplier, "elastic"); }
        if(u.skill !== 'AMATERASU') { skillMesh.position.copy(u.group.position).add(new THREE.Vector3(35, 30, 0)); scene.add(skillMesh); skillMeshes.push(skillMesh); }
        await new Promise(r => setTimeout(r, 1200 / gameSpeedMultiplier));
        cinematic.classList.remove('active-cinematic');
        await new Promise(r => setTimeout(r, 400 / gameSpeedMultiplier));
        cinematic.style.display = 'none';
        if(u.skill === 'AMATERASU') {
            scene.add(skillMesh); skillMeshes.push(skillMesh); skillMesh.scale.set(1.5, 1.5, 1.5); 
            const dmg = u.enemy ? 5000 : u.atk * 15;
            target.cur = Math.max(0, target.cur - dmg);
            showDamage(target, dmg, "#ff0000"); screenShake(18, 1200);
            await new Promise(r => setTimeout(r, 1500 / gameSpeedMultiplier));
            await tweenScale(skillMesh, new THREE.Vector3(0, 0, 0), 400 / gameSpeedMultiplier, "easeIn");
            scene.remove(skillMesh); skillMeshes = skillMeshes.filter(m => m !== skillMesh);
            const miniFlame = createAmaterasuVFX(new THREE.Vector3(0,0,0)); miniFlame.scale.set(0.25, 0.25, 0.25); miniFlame.position.set(0, 20, 0);
            target.group.add(miniFlame); target.dots.push({ type: 'amaterasu', damage: 500, color: 0x000000, mesh: miniFlame });
        } else {
            const startPos = u.group.position.clone();
            const targetPos = target.group.position.clone().add(new THREE.Vector3(u.enemy ? 100 : -100, 0, 0));
            const duration = 300 / gameSpeedMultiplier; const startTime = Date.now();
            await new Promise(res => {
                const loop = () => {
                    const elapsed = Date.now() - startTime; const p = Math.min(1, elapsed / duration);
                    u.group.position.lerpVectors(startPos, targetPos, p * p * (3 - 2 * p));
                    if(skillMesh.position) skillMesh.position.copy(u.group.position).add(new THREE.Vector3(35, 30, 0));
                    if(p < 1 && isCombatActive) requestAnimationFrame(loop); else res();
                }; loop();
            });
            const dmg = (u.enemy ? 800 : (u.atk * 10 || 4000));
            target.cur = Math.max(0, target.cur - dmg);
            showDamage(target, dmg, "#44ccff"); createVFX(target.group.position, u.skillColor, 60, (u.skill === 'LÔI THIẾT' ? 'chidori' : u.skill || 'spark').toLowerCase());
            screenShake(15, 300); await new Promise(r => setTimeout(r, 400 / gameSpeedMultiplier));
            scene.remove(skillMesh); skillMeshes = skillMeshes.filter(m => m !== skillMesh);
            if(u.group.userData.rightShoulder) tweenRotation(u.group.userData.rightShoulder, { z: 0, x: 0 }, 400 / gameSpeedMultiplier, "easeOut");
            await tween(u.group.position, startPos, 400 / gameSpeedMultiplier, "easeOut");
        }
    }

    function createAmaterasuVFX(targetPos) {
        const group = new THREE.Group(); group.position.copy(targetPos);
        for(let i=0; i<100; i++) {
            const angle = (i/100) * Math.PI * 2, radius = 40 + Math.random() * 35, height = 150 + Math.random() * 100, width = 8 + Math.random() * 8;
            const flame = new THREE.Mesh(new THREE.ConeGeometry(width, height, 3), new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.95 }));
            flame.position.set(Math.cos(angle) * radius, height/2 - 85, Math.sin(angle) * radius);
            flame.userData = { orbitSpeed: 0.04 + Math.random() * 0.08, radius: radius }; group.add(flame);
        }
        group.userData.type = 'amaterasu_flames'; return group;
    }

    function createAnimeRasengan() {
        const group = new THREE.Group();
        group.add(new THREE.Mesh(new THREE.SphereGeometry(24, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff })));
        group.add(new THREE.Mesh(new THREE.SphereGeometry(32, 32, 32), new THREE.MeshBasicMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending })));
        for(let i=0; i<100; i++) {
            const radius = 35 + Math.random() * 12, points = [];
            for(let j=0; j<=24; j++) { const angle = (j/24) * Math.PI * 2; points.push(new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0)); }
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color: 0xbbfaff, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending }));
            line.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            line.userData = { axis: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize(), speed: 0.15 + Math.random()*0.25 };
            group.add(line);
        }
        group.userData.type = 'anime_rasengan'; return group;
    }

    function createChidoriMesh() {
        const group = new THREE.Group(); 
        group.add(new THREE.Mesh(new THREE.SphereGeometry(22, 16, 16), new THREE.MeshBasicMaterial({color: 0x00f2ff, transparent: true, opacity: 0.9})));
        group.add(new THREE.Mesh(new THREE.SphereGeometry(28, 16, 16), new THREE.MeshBasicMaterial({color: 0x88eaff, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending})));
        
        for(let i=0; i<90; i++) {
            const points = []; 
            let currentPos = new THREE.Vector3(0,0,0); 
            const randomLength = 130 + Math.random() * 180;
            const mainDir = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize();
            
            for(let s=0; s<=8; s++) { 
                points.push(currentPos.clone()); 
                currentPos.add(mainDir.clone().multiplyScalar(randomLength / 8)).add(new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40)); 
            }
            
            const boltColor = 0x00f2ff;
            const bolt = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points), 
                new THREE.LineBasicMaterial({ color: boltColor, transparent: true, opacity: 0.9, linewidth: 3 }) 
            );
            bolt.userData = { originalPoints: points.map(p => p.clone()) }; 
            group.add(bolt);
        }
        group.userData.type = 'chidori_detail'; return group;
    }

    function createVFX(pos, color, count, type) {
        for(let i=0; i<count; i++) {
            const m = new THREE.Mesh(new THREE.SphereGeometry(type === 'burn' || type === 'fire' ? 4 : 1.5, 8, 8), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 }));
            m.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*50, 20 + (Math.random()-0.5)*50, (Math.random()-0.5)*50));
            const force = (type === 'fire' ? 30 : 20) * (gameSpeedMultiplier === 2 ? 1.5 : 1);
            m.userData = { vel: new THREE.Vector3((Math.random()-0.5)*force, (Math.random()-0.5)*force, (Math.random()-0.5)*force), life: 1.0 };
            scene.add(m); particles.push(m);
        }
    }

    function screenShake(strength, duration) {
        const start = Date.now();
        const loop = () => {
            const elapsed = Date.now() - start;
            if(elapsed < duration) {
                const off = (Math.random()-0.5)*strength; camera.position.x += off; camera.position.y += off;
                setTimeout(() => { camera.position.x -= off; camera.position.y -= off; }, 16);
                requestAnimationFrame(loop);
            }
        }; loop();
    }

    function updateBars(u) {
        if(!u.group) return;
        const v = new THREE.Vector3(); u.group.getWorldPosition(v);
        const p = v.clone().add(new THREE.Vector3(0, u.isBoss ? 180 : 100, 0)).project(camera);
        let el = document.getElementById(`bars-${u.id}`);
        if(!el) {
            el = document.createElement('div'); el.id = `bars-${u.id}`; el.className = 'ui-unit-container';
            el.innerHTML = `<div class="bar-bg"><div class="hp-fill"></div></div><div class="bar-bg mp-box" style="height:2px"><div class="mp-fill"></div></div>`;
            document.getElementById('battle-layer').appendChild(el); u.bar = el;
        }
        el.style.left = `${(p.x * 0.5 + 0.5) * window.innerWidth}px`; el.style.top = `${(p.y * -0.5 + 0.5) * window.innerHeight}px`;
        el.querySelector('.hp-fill').style.width = `${(u.cur/u.maxHp)*100}%`;
        if(!u.isBoss) el.querySelector('.mp-fill').style.width = `${u.mp}%`;
        el.style.display = (u.cur <= 0 || gameState !== 'battle') ? 'none' : 'block';
    }

    function tween(obj, target, ms, type = "smooth") {
        return new Promise(res => {
            const start = obj.clone(), startTime = Date.now();
            const loop = () => {
                const elapsed = Date.now() - startTime; let p = Math.min(1, elapsed / ms);
                if(type === "easeIn") p = p * p; if(type === "easeOut") p = 1 - Math.pow(1 - p, 3);
                obj.lerpVectors(start, target, p); if(p < 1 && isCombatActive) requestAnimationFrame(loop); else res();
            }; loop();
        });
    }

    function tweenScale(obj, target, ms, type = "smooth") {
        return new Promise(res => {
            const start = obj.scale.clone(), startTime = Date.now();
            const loop = () => {
                const elapsed = Date.now() - startTime; let p = Math.min(1, elapsed / ms);
                if(type === "easeIn") p = p * p; if(type === "easeOut") p = 1 - Math.pow(1 - p, 3);
                obj.scale.lerpVectors(start, target, p); if(p < 1 && isCombatActive) requestAnimationFrame(loop); else res();
            }; loop();
        });
    }

    function tweenRotation(obj, target, ms, type) {
        return new Promise(res => {
            const startX = obj.rotation.x, startZ = obj.rotation.z, startTime = Date.now();
            const loop = () => {
                const elapsed = Date.now() - startTime; let p = Math.min(1, elapsed / ms);
                obj.rotation.x = startX + (target.x - startX) * p; obj.rotation.z = startZ + (target.z - startZ) * p;
                if(p < 1 && isCombatActive) requestAnimationFrame(loop); else res();
            }; loop();
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        if(gameState === 'battle') {
            units.forEach(u => updateBars(u));
            const allMeshes = [...skillMeshes];
            units.forEach(u => u.group.children.forEach(child => { if (child.userData && child.userData.type === 'amaterasu_flames') allMeshes.push(child); }));
            allMeshes.forEach(m => {
                const speedScale = gameSpeedMultiplier;
                if(m.userData.type === 'anime_rasengan') m.children.forEach(child => { if(child.userData.axis) child.rotateOnAxis(child.userData.axis, child.userData.speed * speedScale); });
                if(m.userData.type === 'chidori_detail') m.children.forEach(child => { if(child instanceof THREE.Line) { const positions = child.geometry.attributes.position.array, orig = child.userData.originalPoints; for(let i=1; i<orig.length; i++) { positions[i*3] = orig[i].x + (Math.random()-0.5)*40; positions[i*3+1] = orig[i].y + (Math.random()-0.5)*40; positions[i*3+2] = orig[i].z + (Math.random()-0.5)*40; } child.geometry.attributes.position.needsUpdate = true; } });
                if(m.userData.type === 'amaterasu_flames') m.children.forEach(child => { if(child.userData.orbitSpeed) { const ud = child.userData, ang = time * ud.orbitSpeed * 10 * speedScale; child.position.x = Math.cos(ang) * ud.radius; child.position.z = Math.sin(ang) * ud.radius; } });
            });
            for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; p.position.add(p.userData.vel); p.userData.life -= 0.02 * gameSpeedMultiplier; p.scale.setScalar(p.userData.life); if (p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); } }
        }
        renderer.render(scene, camera);
    }

    window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
    window.onload = init;
</script>
</body>
</html>

